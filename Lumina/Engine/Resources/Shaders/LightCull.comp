#version 450 core
#pragma shader_stage(compute)

#include "Includes/Common.glsl"

#define LOCAL_SIZE 128
layout(local_size_x = LOCAL_SIZE, local_size_y = 1, local_size_z = 1) in;

layout(set = 0, binding = 0) restrict buffer BufferSSBO
{
    FCluster Clusters[];
} Clusters;

layout(set = 0, binding = 1) readonly buffer FLightData
{
    uint    NumLights;
    uint    Padding[3];

    vec3    SunDirection;
    bool    bHasSun;

    vec4    CascadeSplits;

    vec4    AmbientLight;

    FLight  Lights[MAX_LIGHTS];
} LightData;

layout(push_constant) uniform PushConstants
{
    mat4 ViewMatrix;
} PC;


bool SphereAABBIntersection(vec3 Center, float Radius, vec3 AABBMin, vec3 AABBMax)
{
    vec3 ClosestPoint = clamp(Center, AABBMin, AABBMax);
    
    float DistanceSquared = dot(ClosestPoint - Center, ClosestPoint - Center);
    
    return DistanceSquared <= Radius * Radius;
}

bool TestSphereAABB(uint i, FCluster Cluster)
{
    vec3 Center = vec4(PC.ViewMatrix * vec4(LightData.Lights[i].Position, 1.0)).xyz;
    float Radius = LightData.Lights[i].Radius;
    
    vec3 AABBMin = Cluster.MinPoint.xyz;
    vec3 AABBMax = Cluster.MaxPoint.xyz;
    
    return SphereAABBIntersection(Center, Radius, AABBMin, AABBMax);
}

void main()
{
    uint LightCount = LightData.NumLights;
    uint Index = gl_WorkGroupID.x * LOCAL_SIZE + gl_LocalInvocationID.x;

    Clusters.Clusters[Index].Count = 0;

    for(uint i = 0; i < LightCount; ++i)
    {
        if(HasFlag(LightData.Lights[i].Flags, LIGHT_FLAG_TYPE_DIRECTIONAL))
        {
            continue;
        }
        
        if(TestSphereAABB(i, Clusters.Clusters[Index]) && Clusters.Clusters[Index].Count < 100)
        {
            uint Count = Clusters.Clusters[Index].Count;
            Clusters.Clusters[Index].LightIndices[Count] = i;
            Clusters.Clusters[Index].Count++;
        }
    }
}

